#!/usr/bin/env python3
"""
NEUROPLAST-ANN Model Loader v4.3
=================================
Programme Python avec TensorFlow pour tester le chargement des mod√®les
sauvegard√©s par NEUROPLAST-ANN framework.

Fonctionnalit√©s:
- Chargement des mod√®les .h5 et .pth
- Conversion vers TensorFlow
- Tests de pr√©diction
- Analyse des performances
- Visualisation des architectures
"""

import os
import sys
import json
import numpy as np
import pandas as pd
import tensorflow as tf
from pathlib import Path
import matplotlib.pyplot as plt
import seaborn as sns
from sklearn.metrics import accuracy_score, classification_report, confusion_matrix
from colorama import init, Fore, Style, Back
import h5py
import warnings

# Initialiser colorama pour les couleurs dans le terminal
init(autoreset=True)

class NeuroplastModelLoader:
    """Classe pour charger et tester les mod√®les NEUROPLAST-ANN"""
    
    def __init__(self, base_directory="../"):
        """
        Initialiser le chargeur de mod√®les
        
        Args:
            base_directory (str): R√©pertoire de base contenant les mod√®les sauvegard√©s
        """
        self.base_directory = Path(base_directory)
        self.model_directories = []
        self.loaded_models = {}
        self.model_info = {}
        
        print(f"{Fore.CYAN}üöÄ NEUROPLAST-ANN Model Loader v4.3{Style.RESET_ALL}")
        print(f"{Fore.CYAN}{'='*50}{Style.RESET_ALL}")
        
        self._discover_model_directories()
    
    def _discover_model_directories(self):
        """D√©couvrir automatiquement les r√©pertoires de mod√®les"""
        pattern = "best_models_neuroplast_*"
        self.model_directories = list(self.base_directory.glob(pattern))
        
        if self.model_directories:
            print(f"{Fore.GREEN}‚úÖ R√©pertoires de mod√®les trouv√©s:{Style.RESET_ALL}")
            for i, dir_path in enumerate(self.model_directories, 1):
                dataset_name = dir_path.name.replace("best_models_neuroplast_", "")
                print(f"   {i}. {Fore.YELLOW}{dataset_name}{Style.RESET_ALL} ‚Üí {dir_path}")
        else:
            print(f"{Fore.RED}‚ùå Aucun r√©pertoire de mod√®les trouv√©{Style.RESET_ALL}")
            print(f"   Recherche dans: {self.base_directory}")
            print(f"   Pattern: {pattern}")
    
    def load_model_info(self, model_dir):
        """Charger les informations des mod√®les depuis best_models_info.json"""
        info_file = model_dir / "best_models_info.json"
        
        if info_file.exists():
            try:
                with open(info_file, 'r') as f:
                    return json.load(f)
            except Exception as e:
                print(f"{Fore.RED}‚ùå Erreur lecture {info_file}: {e}{Style.RESET_ALL}")
                return None
        else:
            print(f"{Fore.YELLOW}‚ö†Ô∏è Fichier info non trouv√©: {info_file}{Style.RESET_ALL}")
            return None
    
    def load_h5_model(self, h5_file):
        """Charger un mod√®le .h5 et le convertir en TensorFlow"""
        try:
            print(f"{Fore.BLUE}üìÇ Chargement du mod√®le H5: {h5_file.name}{Style.RESET_ALL}")
            
            # Lire le fichier H5 cr√©√© par NEUROPLAST-ANN
            with h5py.File(h5_file, 'r') as f:
                # Afficher la structure du fichier
                print(f"   Structure H5:")
                self._print_h5_structure(f, "   ")
                
                # Extraire les informations du mod√®le
                if 'model_info' in f:
                    model_info = {}
                    for key in f['model_info'].keys():
                        if isinstance(f['model_info'][key][()], bytes):
                            model_info[key] = f['model_info'][key][()].decode('utf-8')
                        else:
                            model_info[key] = f['model_info'][key][()]
                    
                    print(f"   üìä Info mod√®le: {model_info}")
                
                # Extraire l'architecture
                if 'architecture' in f:
                    layers = []
                    for layer_name in f['architecture'].keys():
                        layer_group = f['architecture'][layer_name]
                        layer_info = {
                            'name': layer_name,
                            'input_size': layer_group['input_size'][()],
                            'output_size': layer_group['output_size'][()],
                            'activation': layer_group['activation'][()].decode('utf-8') if isinstance(layer_group['activation'][()], bytes) else layer_group['activation'][()]
                        }
                        
                        # Extraire les poids si disponibles
                        if 'weights' in layer_group:
                            layer_info['weights'] = layer_group['weights'][:]
                        if 'biases' in layer_group:
                            layer_info['biases'] = layer_group['biases'][:]
                        
                        layers.append(layer_info)
                    
                    # Cr√©er un mod√®le TensorFlow √©quivalent
                    tf_model = self._create_tensorflow_model(layers)
                    return tf_model, model_info, layers
                
        except Exception as e:
            print(f"{Fore.RED}‚ùå Erreur chargement H5: {e}{Style.RESET_ALL}")
            return None, None, None
    
    def _print_h5_structure(self, group, indent=""):
        """Afficher la structure d'un fichier H5"""
        for key in group.keys():
            item = group[key]
            if isinstance(item, h5py.Group):
                print(f"{indent}üìÅ {key}/")
                self._print_h5_structure(item, indent + "  ")
            else:
                print(f"{indent}üìÑ {key}: {item.shape} {item.dtype}")
    
    def _create_tensorflow_model(self, layers):
        """Cr√©er un mod√®le TensorFlow √† partir des couches NEUROPLAST-ANN"""
        try:
            model = tf.keras.Sequential()
            
            for i, layer_info in enumerate(layers):
                input_size = layer_info['input_size']
                output_size = layer_info['output_size']
                activation = layer_info['activation'].lower()
                
                # Mapper les activations NEUROPLAST-ANN vers TensorFlow
                activation_map = {
                    'relu': 'relu',
                    'sigmoid': 'sigmoid',
                    'tanh': 'tanh',
                    'gelu': 'gelu',
                    'leaky_relu': tf.keras.layers.LeakyReLU(),
                    'elu': 'elu',
                    'mish': 'mish',
                    'swish': 'swish',
                    'neuroplast': 'relu'  # Fallback pour neuroplast
                }
                
                tf_activation = activation_map.get(activation, 'relu')
                
                if i == 0:
                    # Premi√®re couche avec input_shape
                    layer = tf.keras.layers.Dense(
                        output_size,
                        activation=tf_activation,
                        input_shape=(input_size,),
                        name=f"dense_{i+1}"
                    )
                else:
                    layer = tf.keras.layers.Dense(
                        output_size,
                        activation=tf_activation,
                        name=f"dense_{i+1}"
                    )
                
                model.add(layer)
                
                # Appliquer les poids si disponibles
                if 'weights' in layer_info and 'biases' in layer_info:
                    weights = layer_info['weights']
                    biases = layer_info['biases']
                    
                    # Reshape si n√©cessaire
                    if len(weights.shape) == 1:
                        weights = weights.reshape(input_size, output_size)
                    
                    layer.set_weights([weights, biases])
            
            # Compiler le mod√®le
            model.compile(
                optimizer='adam',
                loss='binary_crossentropy' if layers[-1]['output_size'] == 1 else 'categorical_crossentropy',
                metrics=['accuracy']
            )
            
            print(f"{Fore.GREEN}‚úÖ Mod√®le TensorFlow cr√©√© avec succ√®s{Style.RESET_ALL}")
            return model
            
        except Exception as e:
            print(f"{Fore.RED}‚ùå Erreur cr√©ation mod√®le TensorFlow: {e}{Style.RESET_ALL}")
            return None
    
    def test_model_prediction(self, model, dataset_name):
        """Tester les pr√©dictions du mod√®le avec des donn√©es synth√©tiques"""
        try:
            print(f"{Fore.BLUE}üß™ Test de pr√©diction pour {dataset_name}{Style.RESET_ALL}")
            
            # G√©n√©rer des donn√©es de test synth√©tiques
            input_shape = model.input_shape[1]
            test_data = np.random.randn(10, input_shape)
            
            # Faire des pr√©dictions
            predictions = model.predict(test_data, verbose=0)
            
            print(f"   üìä Forme des donn√©es d'entr√©e: {test_data.shape}")
            print(f"   üìä Forme des pr√©dictions: {predictions.shape}")
            print(f"   üìä √âchantillon de pr√©dictions:")
            
            for i, pred in enumerate(predictions[:5]):
                if len(pred) == 1:
                    print(f"      √âchantillon {i+1}: {pred[0]:.4f}")
                else:
                    print(f"      √âchantillon {i+1}: {pred}")
            
            return True
            
        except Exception as e:
            print(f"{Fore.RED}‚ùå Erreur test pr√©diction: {e}{Style.RESET_ALL}")
            return False
    
    def analyze_model_architecture(self, model, dataset_name):
        """Analyser et afficher l'architecture du mod√®le"""
        print(f"{Fore.BLUE}üèóÔ∏è Architecture du mod√®le {dataset_name}{Style.RESET_ALL}")
        
        # R√©sum√© du mod√®le
        print("   üìã R√©sum√©:")
        model.summary(print_fn=lambda x: print(f"      {x}"))
        
        # Statistiques
        total_params = model.count_params()
        trainable_params = sum([tf.keras.backend.count_params(w) for w in model.trainable_weights])
        
        print(f"   üìä Param√®tres totaux: {total_params:,}")
        print(f"   üìä Param√®tres entra√Ænables: {trainable_params:,}")
        
        return {
            'total_params': total_params,
            'trainable_params': trainable_params,
            'layers': len(model.layers)
        }
    
    def visualize_model(self, model, dataset_name, save_path=None):
        """Visualiser l'architecture du mod√®le"""
        try:
            if save_path is None:
                save_path = f"model_architecture_{dataset_name}.png"
            
            tf.keras.utils.plot_model(
                model,
                to_file=save_path,
                show_shapes=True,
                show_layer_names=True,
                rankdir='TB',
                expand_nested=True,
                dpi=96
            )
            
            print(f"{Fore.GREEN}‚úÖ Diagramme sauvegard√©: {save_path}{Style.RESET_ALL}")
            return save_path
            
        except Exception as e:
            print(f"{Fore.YELLOW}‚ö†Ô∏è Impossible de cr√©er le diagramme: {e}{Style.RESET_ALL}")
            return None
    
    def load_and_test_all_models(self):
        """Charger et tester tous les mod√®les trouv√©s"""
        results = {}
        
        for model_dir in self.model_directories:
            dataset_name = model_dir.name.replace("best_models_neuroplast_", "")
            
            print(f"\n{Fore.MAGENTA}{'='*60}{Style.RESET_ALL}")
            print(f"{Fore.MAGENTA}üîç ANALYSE DU DATASET: {dataset_name.upper()}{Style.RESET_ALL}")
            print(f"{Fore.MAGENTA}{'='*60}{Style.RESET_ALL}")
            
            # Charger les informations des mod√®les
            model_info = self.load_model_info(model_dir)
            
            # Chercher les fichiers de mod√®les
            h5_files = list(model_dir.glob("*.h5"))
            
            if h5_files:
                print(f"{Fore.GREEN}üìÅ {len(h5_files)} mod√®les H5 trouv√©s{Style.RESET_ALL}")
                
                # Tester le premier mod√®le (meilleur)
                best_model_file = model_dir / "model_1.h5"
                if best_model_file.exists():
                    model, info, layers = self.load_h5_model(best_model_file)
                    
                    if model is not None:
                        # Analyser l'architecture
                        arch_stats = self.analyze_model_architecture(model, dataset_name)
                        
                        # Tester les pr√©dictions
                        pred_success = self.test_model_prediction(model, dataset_name)
                        
                        # Visualiser le mod√®le
                        viz_path = self.visualize_model(model, dataset_name)
                        
                        # Stocker les r√©sultats
                        results[dataset_name] = {
                            'model': model,
                            'info': info,
                            'layers': layers,
                            'architecture_stats': arch_stats,
                            'prediction_test': pred_success,
                            'visualization': viz_path,
                            'model_info_json': model_info
                        }
                        
                        self.loaded_models[dataset_name] = model
                        self.model_info[dataset_name] = info
                    
                else:
                    print(f"{Fore.RED}‚ùå Fichier model_1.h5 non trouv√©{Style.RESET_ALL}")
            else:
                print(f"{Fore.YELLOW}‚ö†Ô∏è Aucun fichier .h5 trouv√© dans {model_dir}{Style.RESET_ALL}")
        
        return results
    
    def generate_comparison_report(self, results):
        """G√©n√©rer un rapport de comparaison des mod√®les"""
        print(f"\n{Fore.CYAN}{'='*70}{Style.RESET_ALL}")
        print(f"{Fore.CYAN}üìä RAPPORT DE COMPARAISON DES MOD√àLES{Style.RESET_ALL}")
        print(f"{Fore.CYAN}{'='*70}{Style.RESET_ALL}")
        
        if not results:
            print(f"{Fore.RED}‚ùå Aucun mod√®le charg√© pour la comparaison{Style.RESET_ALL}")
            return
        
        # Cr√©er un DataFrame pour la comparaison
        comparison_data = []
        
        for dataset_name, result in results.items():
            if result['architecture_stats']:
                stats = result['architecture_stats']
                comparison_data.append({
                    'Dataset': dataset_name,
                    'Couches': stats['layers'],
                    'Param√®tres Totaux': stats['total_params'],
                    'Param√®tres Entra√Ænables': stats['trainable_params'],
                    'Test Pr√©diction': '‚úÖ' if result['prediction_test'] else '‚ùå',
                    'Visualisation': '‚úÖ' if result['visualization'] else '‚ùå'
                })
        
        if comparison_data:
            df = pd.DataFrame(comparison_data)
            print(f"\n{Fore.GREEN}üìã Tableau de comparaison:{Style.RESET_ALL}")
            print(df.to_string(index=False))
            
            # Sauvegarder le rapport
            report_file = "model_comparison_report.csv"
            df.to_csv(report_file, index=False)
            print(f"\n{Fore.GREEN}‚úÖ Rapport sauvegard√©: {report_file}{Style.RESET_ALL}")
        
        # Statistiques globales
        total_models = len(results)
        successful_loads = sum(1 for r in results.values() if r['model'] is not None)
        
        print(f"\n{Fore.BLUE}üìà Statistiques globales:{Style.RESET_ALL}")
        print(f"   üéØ Mod√®les trouv√©s: {total_models}")
        print(f"   ‚úÖ Chargements r√©ussis: {successful_loads}")
        print(f"   üìä Taux de succ√®s: {successful_loads/total_models*100:.1f}%" if total_models > 0 else "   üìä Taux de succ√®s: 0%")

def main():
    """Fonction principale"""
    print(f"{Fore.CYAN}üöÄ D√©marrage du test de chargement des mod√®les NEUROPLAST-ANN{Style.RESET_ALL}")
    
    # Cr√©er le chargeur de mod√®les
    loader = NeuroplastModelLoader()
    
    if not loader.model_directories:
        print(f"\n{Fore.RED}‚ùå Aucun mod√®le trouv√©. Assurez-vous d'avoir ex√©cut√© NEUROPLAST-ANN avec --test-all{Style.RESET_ALL}")
        print(f"{Fore.YELLOW}üí° Exemple: ./neuroplast-ann --config config/cancer_simple.yml --test-all{Style.RESET_ALL}")
        return
    
    # Charger et tester tous les mod√®les
    results = loader.load_and_test_all_models()
    
    # G√©n√©rer le rapport de comparaison
    loader.generate_comparison_report(results)
    
    print(f"\n{Fore.GREEN}üéâ Test de chargement termin√© avec succ√®s !{Style.RESET_ALL}")
    print(f"{Fore.CYAN}üìÅ Fichiers g√©n√©r√©s dans le r√©pertoire courant{Style.RESET_ALL}")

if __name__ == "__main__":
    # Supprimer les warnings TensorFlow pour un affichage plus propre
    warnings.filterwarnings('ignore')
    os.environ['TF_CPP_MIN_LOG_LEVEL'] = '2'
    
    main() 